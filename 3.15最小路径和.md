# 3.15最小路径和

## 题目描述：

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

示例 1：


输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
示例 2：

输入：grid = [[1,2,3],[4,5,6]]
输出：12


提示：

m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 200

## 代码：

```java
class Solution {
  public int minPathSum(int[][] grid) {
        // 初始化记忆化数组
        int[][] memo = new int[grid.length][grid[0].length];
        for (int[] ints : memo) {
            Arrays.fill(ints, Integer.MAX_VALUE);
        }
        int m= grid.length;
        int n = grid[0].length;
        return dfs(0, 0, m, n, memo, grid);

    }

    private int dfs(int i, int i1, int m, int n, int[][] memo, int[][] grid) {
        if(i == m-1 && i1 == n-1){
            return grid[i][i1];
        }

        if(memo[i][i1] !=Integer.MAX_VALUE){
            return memo[i][i1];
        }
        if(i < m-1){

            memo[i][i1] = Math.min( memo[i][i1], dfs(i+1, i1, m, n, memo, grid)+ grid[i][i1]) ;
             
        }
        if(i1 < n-1){

            memo[i][i1] = Math.min( memo[i][i1], dfs(i, i1+1, m, n, memo, grid)+ grid[i][i1]);
          
        }
        return memo[i][i1];
    }
}
```

## 题解：

同样使用了dfs加记忆数组，记下这个顶点的最小路径和，同时进行比较，最终递归出从顶点出发的最小路径和，但是一开始把记忆数组的值初始化为200会时间超限但是改成 Integer.MAX_VALUE，我不明白

在动态规划或记忆化搜索中，`memo` 数组的初始值设置直接影响缓存的正确性。将初始值从 `200` 改为 `Integer.MAX_VALUE` 解决了以下关键问题，从而消除了时间超限：

---

### **1. 避免缓存误判，减少冗余递归**
- **原问题**：**初始值 `200` 可能小于实际路径和。当某节点的真实最小路径和超过 `200` 时**：
  - 第一次计算后，`memo[i][j]` 被更新为实际值（如 `300`）。
  - 后续访问该节点时，由于 `memo[i][j] != 200`，直接返回缓存值 `300`。
  - **但** 若存在另一条路径到该节点的实际最小路径和为 `250`（更小），则无法覆盖缓存值，导致错误地剪枝，程序被迫继续探索更多路径，增加递归深度。

- **优化后**：初始值设为 `Integer.MAX_VALUE`，只有真实计算过的节点才会被标记。每个节点确保仅计算一次，避免重复递归。

---

### **2. 正确覆盖所有可能路径**
- **错误初始值的影响**：当 `memo` 初始值设为 `200`，某些节点的真实最小路径和可能刚好为 `200`。此时：
  - 首次访问时，`memo[i][j] == 200` 被误判为已缓存，直接返回而未计算。
  - **导致后续路径基于错误值推导，最终结果错误且可能被迫回溯，增加无效递归。**

- **正确初始值的作用**：所有节点初始状态明确为“未计算”，确保每个节点完整探索所有可能路径。

---

### **3. 示例分析**
假设网格为：
```java
grid = [
    [100, 100, 100],
    [100, 100, 100]
]
```
- **正确最小路径和**：`100→100→100→100 = 400`。
- **错误初始值 `200` 的流程**：
  1. 节点 `(0,0)` 计算后缓存 `200 + min(dfs(1,0), dfs(0,1))`，假设误存为 `500`。
  2. 后续路径访问 `(0,0)` 时直接返回 `500`，导致后续所有推导基于错误值，最终结果错误且无法终止。

- **正确初始值 `Integer.MAX_VALUE` 的流程**：
  1. 所有节点首次访问时计算并缓存真实值。
  2. 每个节点仅计算一次，递归深度和次数严格为 \(O(mn)\)。

---

### **4. 时间复杂度对比**
| 初始值              | 实际时间复杂度            | 原因                               |
| ------------------- | ------------------------- | ---------------------------------- |
| `200`               | 可能退化为 \(O(2^{m+n})\) | 缓存误判导致重复递归和无效路径探索 |
| `Integer.MAX_VALUE` | 严格 \(O(mn)\)            | 每个节点仅计算一次，记忆化正确剪枝 |

---

### **5. 总结**
- **初始值 `200`**：导致缓存逻辑错误，部分节点无法正确剪枝，递归次数指数级增长。
- **初始值 `Integer.MAX_VALUE`**：确保缓存严格按实际计算结果更新，递归次数线性可控。  
  通过修正初始值，记忆化机制得以正确工作，避免无效递归，从而解决时间超限问题。