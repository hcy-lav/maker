# 3.13旋转链表

## 题目描述：

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置

示例 1：


输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
示例 2：

输入：head = [0,1,2], k = 4
输出：[2,0,1]

## 代码解答：

### 我的想法

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
   public ListNode rotateRight(ListNode head, int k) {
    if(head==null){
            return null;
        }
        List<Integer> arr= new ArrayList<>();
        while (head!=null){
            arr.add(head.val);
            head=head.next;
        }
        int size = arr.size();
        int index = k % size;
        int[] ints = new int[size];
        for (int i = 0; i < size; i++) {
            ints[(i+index)%size]=arr.get(i);
        }
        ListNode listNode = new ListNode();
        ListNode listNode2 = listNode;
        for(int i = 0; i < size; i++) {
            ListNode listNode1 = new ListNode();
            listNode1.val = ints[i];
            listNode.next = listNode1;
            listNode=listNode1;
        }
        return listNode2.next;
    }
}
```

### 合链与断链

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        ListNode s = head;
        
        if(head == null || head.next == null){ //先判断链表等于0或者1的情况
            return head;
        }
        int size = 1;
        while(s.next != null) {//闭环的同时计算链表长度
            s = s.next;
            size++;
        }
        s.next = head;
        
        k = size - k%size;//计算移动后新的头指针在环形链表中的索引（从原链表头指针开始的索引）
        for (int i = 0; i < k-1; i++){//移动头指针到新头指针的前一个节点
            head = head.next;
        }
        s = head.next;//取信头指针的值
        head.next =null;//断开环
        return s;


    }
}

```

## 题解：

自己的想法就是暴力解法，把链表的值放在list里然后把要移动的位置进行加减，最后得到再放到链表里

核心思想：将链表首尾相连形成环，通过数学计算找到新的头节点位置，最后断开环
     1.处理边界情况：链表为空或仅有一个节点时直接返回。
     2. 计算长度并成环：遍历链表计算长度 size，同时将尾节点指向头节点形成环。
     3.确定新头位置：旋转 k 次等价于将后 k % size 个节点移到链表前面。因此，新头节点的位置是 size - k % size。
    4.定位并断环：移动指针到新头节点的前驱位置，断开环并返回新头节点。