# 2.24交换节点

## 题目：

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

**示例 1：**

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

## 代码：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
      public ListNode swapPairs(ListNode head) {
        // 创建一个虚拟头节点，方便处理链表头部的交换
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        // 使用一个指针指向当前处理的节点的前一个节点
        ListNode prev = dummy;

        while (head != null && head.next != null) {
            // 当前节点和下一个节点
            ListNode first = head;
            ListNode second = head.next;

            // 交换两个节点
            prev.next = second;
            first.next = second.next;
            second.next = first;

            // 更新指针
            prev = first;
            head = first.next;
        }

        // 返回虚拟头节点的下一个节点，即交换后的链表头
        return dummy.next;
    }
}
```

## 题解：

1. **虚拟头节点**：
   - 使用虚拟头节点 `dummy`，方便处理链表头部的交换，避免特殊处理头节点。
2. **交换逻辑**：
   - 使用 `prev` 指针指向当前处理节点的前一个节点，确保交换操作不会破坏链表的连接关系。
   - 先调整 `prev.next`，再调整 `first.next` 和 `second.next`，最后更新 `prev` 和 `head`。
3. **边界条件**：
   - 在 `while` 循环中，检查 `head != null && head.next != null`，确保每次交换操作前链表至少有两个节点。
4. **返回结果**：
   - 返回虚拟头节点的下一个节点，即交换后的链表头。

