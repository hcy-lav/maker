# 3.1最大子序列有效长度

## 题目：

给你一个整数数组 nums。

nums 的子序列 sub 的长度为 x ，如果其满足以下条件，则称其为 有效子序列：

(sub[0] + sub[1]) % 2 == (sub[1] + sub[2]) % 2 == ... == (sub[x - 2] + sub[x - 1]) % 2
返回 nums 的 最长的有效子序列 的长度。

一个 子序列 指的是从原数组中删除一些元素（也可以不删除任何元素），剩余元素保持原来顺序组成的新数组。

示例 1：

输入： nums = [1,2,3,4]

输出： 4

解释：

最长的有效子序列是 [1, 2, 3, 4]。

示例 2：

输入： nums = [1,2,1,1,2,1,2]

输出： 6

解释：

最长的有效子序列是 [1, 2, 1, 2, 1, 2]。



## 解答：

```java
class Solution {
    public int maximumLength(int[] nums) {
        int countOdd = 0, countEven = 0;
        int oddLen = 0, evenLen = 0;
        
        for (int num : nums) {
            // 统计奇偶元素的数量
            if (num % 2 == 0) {
                countEven++;
            } else {
                countOdd++;
            }
            
            // 保存当前奇偶子序列的临时值
            int prevOdd = oddLen;
            int prevEven = evenLen;
            
            if (num % 2 == 1) {
                // 当前元素是奇数：
                // - 可以接在偶数结尾的子序列后形成新的奇数结尾序列（长度+1）
                // - 奇数结尾的子序列无法扩展，保持原长度
                oddLen = prevEven + 1;
                evenLen = prevEven; // 偶数结尾的序列保持不变
            } else {
                // 当前元素是偶数：
                // - 可以接在奇数结尾的子序列后形成新的偶数结尾序列（长度+1）
                // - 偶数结尾的子序列无法扩展，保持原长度
                evenLen = prevOdd + 1;
                oddLen = prevOdd; // 奇数结尾的序列保持不变
            }
        }
        
        // 全奇/全偶的最大长度
        int maxSame = Math.max(countOdd, countEven);
        // 奇偶交替的最大长度
        int maxAlternate = Math.max(oddLen, evenLen);
        
        // 取两种情况的最大值
        return Math.max(maxSame, maxAlternate);
    }
}
```

## 题解：

对于和模2为0的情况（偶数和）：假设当前数字 nums[i] 是偶数，那么下一个数字 nums[i+1] 也必须是偶数；同理，如果当前数字是奇数，下一个数字也必须是奇数。
	•	对于和模2为1的情况（奇数和）：假设当前数字 nums[i] 是偶数，那么下一个数字 nums[i+1] 必须是奇数；同理，如果当前数字是奇数，下一个数字必须是偶数。