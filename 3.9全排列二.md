# 3.9全排列二

## 题目：

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



## 代码：

```java
class Solution {
     public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> ds = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        dfs(nums, res, ds, used);
        return res;
    }

    // 深度优先搜索
    private void dfs(int[] nums, List<List<Integer>> res, List<Integer> ds, boolean[] used) {
        // 如果当前路径长度等于数组长度，说明已经找到了一个全排列
        if (ds.size() == nums.length) {
            if(res.contains(ds)) return;
            // 将当前路径添加到结果集中
            res.add(new ArrayList<>(ds));
        }
        // 遍历数组中的每一个元素
        for(int i = 0; i < nums.length; i++) {
            // 如果当前元素没有被使用过
            if (!used[i]) {
                // 将当前元素标记为已使用
                used[i] = true;
                // 将当前元素添加到路径中
                ds.add(nums[i]);
                // 递归调用深度优先搜索
                dfs(nums, res, ds, used);
                // 将当前元素从路径中移除
                ds.remove(ds.size() - 1);
                // 将当前元素标记为未使用
                used[i] = false;
            }

        }
    }
}
```

## 题解：

同样是全排列，同样使用回溯加深度搜索，但是步骤和思想还不是很清楚，可以再多看看，就是相当于一个树进行深度搜索然后回溯，同时运用了boolean[] used = new boolean[nums.length];来表达布尔类型的数组是否加入过

![74149581131](C:\Users\LENOVO~1\AppData\Local\Temp\1741495811317.png)