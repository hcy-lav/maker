# 3.14不同路径

## 题目：

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：


输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
  示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6



## 解答代码：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 初始化记忆化数组
        int[][] memo = new int[m][n];
        return dfs(0, 0, m, n, memo);
    }

    private int dfs(int down, int right, int m, int n, int[][] memo) {
        // 到达终点，返回1条路径
        if (down == m-1 && right == n-1) return 1;
        
        // 若已计算过，直接返回结果
        if (memo[down][right] != 0) return memo[down][right];
        
        int paths = 0;
        // 向下探索
        if (down < m-1) paths += dfs(down+1, right, m, n, memo);
        // 向右探索
        if (right < n-1) paths += dfs(down, right+1, m, n, memo);
        
        // 记录当前坐标的结果
        memo[down][right] = paths;
        return paths;
    }
}
```

## 题解：

这次因为还是这种遍历问题找路径所以还用dfs和回溯算法，但是一开始还是时间超限，还是忘了用记忆，以为这词是找所有路径就不用记忆（可能也是忘了），但是记忆算法可以减少循环次数，真不错